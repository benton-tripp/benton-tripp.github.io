<!DOCTYPE html>
<html lang=en style>

<head>
  <link rel="apple-touch-icon" sizes="180x180" href="../static/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../static/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../static/images/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta charset=utf-8>
  <meta http-equiv=X-UA-Compatible content="IE=edge">
  <meta name=viewport content="width=device-width, initial-scale=1">
  <title>SDM Benchmark Study Part 1: Data Preparation | Benton’s Portfolio/Blog</title>
  <meta property=og:title content="SDM Benchmark Study Part 1: Data Preparation">
  <meta name=author content="Benton Tripp">
  <meta property=og:locale content=en_US>
  <meta name=description content=Overview>
  <meta property=og:description content=Overview>
  <link rel=canonical href=https://benton-tripp.github.io/posts/sdm-benchmark-study-part-1-data-preparation.html>
  <meta property=og:url content=https://benton-tripp.github.io/posts/sdm-benchmark-study-part-1-data-preparation.html>
  <meta property=og:site_name content="Benton’s Portfolio/Blog">
  <meta property=og:type content=article>
  <meta property=article:published_time content=2023-09-10T00:00:00+00:00>
  <script
    type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Benton Tripp"},"dateModified":"2023-09-10T00:00:00+00:00","datePublished":"2023-09-10T00:00:00+00:00","description":"Overview","headline":"SDM Benchmark Study Part 1: Data Preparation","mainEntityOfPage":{"@type":"WebPage","@id":"https://benton-tripp.github.io/posts/sdm-benchmark-study-part-1-data-preparation.html"},"url":"https://benton-tripp.github.io/posts/sdm-benchmark-study-part-1-data-preparation.html"}</script>
  <link type=application/atom+xml rel=alternate href=https://benton-tripp.github.io/feed.xml
    title="Benton's Portfolio/Blog">
  <style>
    body,
    h1,
    h2,
    h3,
    h4,
    p,
    pre,
    hr,
    ol,
    ul {
      margin: 0;
      padding: 0
    }

    body {
      font: 400 16px/1.5 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      color: #111;
      background-color: #fdfdfd;
      -webkit-text-size-adjust: 100%;
      -webkit-font-feature-settings: "kern" 1;
      -moz-font-feature-settings: "kern" 1;
      -o-font-feature-settings: "kern" 1;
      font-feature-settings: "kern" 1;
      font-kerning: normal;
      display: flex;
      min-height: 100vh;
      flex-direction: column
    }

    h1,
    h2,
    h3,
    h4,
    p,
    pre,
    ul,
    ol {
      margin-bottom: 15px
    }

    main {
      display: block
    }

    img {
      max-width: 100%;
      vertical-align: middle
    }

    ul,
    ol {
      margin-left: 30px
    }

    li>ul {
      margin-bottom: 0
    }

    h1,
    h2,
    h3,
    h4 {
      font-weight: 400
    }

    a {
      color: #2a7ae2;
      text-decoration: none
    }

    a:visited {
      color: #1756a9
    }

    a:hover {
      color: #111;
      text-decoration: underline
    }

    .social-media-list a:hover {
      text-decoration: none
    }

    .social-media-list a:hover .username {
      text-decoration: underline
    }

    pre,
    code {
      font-size: 15px;
      border: 1px solid #e8e8e8;
      border-radius: 3px;
      background-color: #eef
    }

    code {
      padding: 1px 5px
    }

    pre {
      padding: 8px 12px;
      overflow-x: auto
    }

    pre>code {
      border: 0;
      padding-right: 0;
      padding-left: 0
    }

    .wrapper {
      max-width: -webkit-calc(800px - (30px*2));
      max-width: calc(800px - (30px*2));
      margin-right: auto;
      margin-left: auto;
      padding-right: 30px;
      padding-left: 30px
    }

    @media screen and (max-width:800px) {
      .wrapper {
        max-width: -webkit-calc(800px - (30px));
        max-width: calc(800px - (30px));
        padding-right: 15px;
        padding-left: 15px
      }
    }

    .wrapper:after,
    .footer-col-wrapper:after {
      content: "";
      display: table;
      clear: both
    }

    .svg-icon {
      width: 16px;
      height: 16px;
      display: inline-block;
      fill: #828282;
      padding-right: 5px;
      vertical-align: text-top
    }

    .social-media-list li+li {
      padding-top: 5px
    }

    table {
      margin-bottom: 30px;
      width: 100%;
      text-align: left;
      color: #3f3f3f;
      border-collapse: collapse;
      border: 1px solid #e8e8e8
    }

    table tr:nth-child(even) {
      background-color: #f7f7f7
    }

    table th,
    table td {
      padding: 10px 15px
    }

    table th {
      background-color: #f0f0f0;
      border: 1px solid #dedede;
      border-bottom-color: #c9c9c9
    }

    table td {
      border: 1px solid #e8e8e8
    }

    .site-header {
      border-top: 5px solid #424242;
      border-bottom: 1px solid #e8e8e8;
      min-height: 55.95px;
      position: relative
    }

    .site-title {
      font-size: 26px;
      font-weight: 300;
      line-height: 54px;
      letter-spacing: -1px;
      margin-bottom: 0;
      float: left
    }

    .site-title,
    .site-title:visited {
      color: #424242
    }

    .site-nav {
      float: right;
      line-height: 54px
    }

    .site-nav .page-link {
      color: #111;
      line-height: 1.5
    }

    .site-nav .page-link:not(:last-child) {
      margin-right: 20px
    }

    @media screen and (max-width:600px) {
      .site-nav {
        position: absolute;
        top: 9px;
        right: 15px;
        background-color: #fdfdfd;
        border: 1px solid #e8e8e8;
        border-radius: 5px;
        text-align: right
      }

      .site-nav label[for="nav-trigger"] {
        display: block;
        float: right;
        width: 36px;
        height: 36px;
        z-index: 2;
        cursor: pointer
      }

      .site-nav .menu-icon>svg {
        fill: #424242
      }

      .site-nav input~.trigger {
        clear: both;
        display: none
      }

      .site-nav input:checked~.trigger {
        display: block;
        padding-bottom: 5px
      }

      .site-nav .page-link {
        display: block;
        padding: 5px 10px;
        margin-left: 20px
      }

      .site-nav .page-link:not(:last-child) {
        margin-right: 0
      }
    }

    .site-footer {
      border-top: 1px solid #e8e8e8;
      padding: 30px 0
    }

    .footer-heading {
      font-size: 18px;
      margin-bottom: 15px
    }

    .contact-list,
    .social-media-list {
      list-style: none;
      margin-left: 0
    }

    .footer-col-wrapper {
      font-size: 15px;
      color: #828282;
      margin-left: -15px
    }

    .footer-col {
      float: left;
      margin-bottom: 15px;
      padding-left: 15px
    }

    .footer-col-1 {
      width: -webkit-calc(35% - (30px/2));
      width: calc(35% - (30px/2))
    }

    .footer-col-2 {
      width: -webkit-calc(20% - (30px/2));
      width: calc(20% - (30px/2))
    }

    .footer-col-3 {
      width: -webkit-calc(45% - (30px/2));
      width: calc(45% - (30px/2))
    }

    @media screen and (max-width:800px) {

      .footer-col-1,
      .footer-col-2 {
        width: -webkit-calc(50% - (30px/2));
        width: calc(50% - (30px/2))
      }

      .footer-col-3 {
        width: -webkit-calc(100% - (30px/2));
        width: calc(100% - (30px/2))
      }
    }

    @media screen and (max-width:600px) {
      .footer-col {
        float: none;
        width: -webkit-calc(100% - (30px/2));
        width: calc(100% - (30px/2))
      }
    }

    .page-content {
      padding: 30px 0;
      flex: 1
    }

    .post-meta {
      font-size: 14px;
      color: #828282
    }

    .post-header {
      margin-bottom: 30px
    }

    .post-title {
      font-size: 42px;
      letter-spacing: -1px;
      line-height: 1
    }

    @media screen and (max-width:800px) {
      .post-title {
        font-size: 36px
      }
    }

    .post-content {
      margin-bottom: 30px
    }

    .post-content h2 {
      font-size: 32px
    }

    @media screen and (max-width:800px) {
      .post-content h2 {
        font-size: 28px
      }
    }

    .post-content h3 {
      font-size: 26px
    }

    @media screen and (max-width:800px) {
      .post-content h3 {
        font-size: 22px
      }
    }

    .post-content h4 {
      font-size: 20px
    }

    @media screen and (max-width:800px) {
      .post-content h4 {
        font-size: 18px
      }
    }

    .sf-hidden {
      display: none !important
    }
    img[src="data:,"],
    source[src="data:,"] {
      display: none !important
    }
  </style>
</head>

<body>
  <header class=site-header role=banner>
    <div class=wrapper><a class=site-title rel=author href=https://benton-tripp.github.io />Benton's Portfolio/Blog</a>
      <nav class=site-nav>
        <input type=checkbox id=nav-trigger class="nav-trigger sf-hidden">
        <label for=nav-trigger>
          <span class="menu-icon sf-hidden">
            <svg viewBox="0 0 18 15" width=18px height=15px>
              <path
                d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z">
              </path>
            </svg>
          </span>
        </label>
        <div class=trigger><a class=page-link href=https://benton-tripp.github.io/archive>Blog Archive</a></div>
      </nav>
    </div>
  </header>
  <main class=page-content aria-label=Content>
    <div class=wrapper>
      <style>
        hr {
          margin-top: 30px;
          margin-bottom: 20px
        }

        .post_navi {
          display: flex
        }

        .post_navi-label {
          font-size: 0.8em;
          opacity: 0.5
        }

        .post_navi .post_navi-item {
          padding: 0 2.2em;
          width: 50%;
          position: relative;
          color: inherit !important
        }

        .post_navi .nav_prev {
          text-align: left
        }

        .post_navi .nav_next {
          text-align: right
        }

        .post_navi .nav_prev .post_navi-arrow {
          left: 0
        }

        .post_navi .nav_next .post_navi-arrow {
          right: 0
        }

        .post_navi .post_navi-arrow {
          position: absolute;
          top: 50%;
          transform: translateY(-50%);
          font-size: 2.5em;
          opacity: 0.3
        }
      </style>
      <article class="post h-entry" itemscope itemtype=http://schema.org/BlogPosting>
        <header class=post-header>
          <h1 class="post-title p-name" itemprop="name headline">SDM Benchmark Study Part 1: Data Preparation</h1>
          <p class=post-meta>
            <time class=dt-published datetime=2023-09-10T00:00:00+00:00 itemprop=datePublished>Sep 10, 2023
            </time>
            • <span itemprop=author itemscope itemtype=http://schema.org/Person><span class="p-author h-card"
                itemprop=name>Benton Tripp</span></span>
          </p>
        </header>
        <div class=share-links>
          <style class=sf-hidden>
            #share-buttons {
              display: inline-block;
              vertical-align: middle
            }

            #share-buttons:after {
              content: "";
              display: block;
              clear: both
            }

            #share-buttons>div {
              position: relative;
              height: 36px;
              width: 32px;
              float: left;
              text-align: center
            }

            #share-buttons>div>svg {
              fill: #d5d5d5
            }

            #share-buttons>div:hover {
              cursor: pointer
            }

            #share-buttons>div.facebook:hover>svg {
              fill: #3B5998
            }

            #share-buttons>div.twitter:hover>svg {
              fill: #55ACEE
            }

            #share-buttons>div.linkedin:hover>svg {
              fill: #0077b5
            }

            #share-buttons>div.gplus:hover>svg {
              fill: #dd4b39
            }

            #share-buttons>div.mail:hover>svg {
              fill: #7D7D7D
            }

            #share-buttons>div.facebook>svg {
              height: 18px;
              margin-top: 9px
            }

            #share-buttons>div.twitter>svg {
              height: 20px;
              margin-top: 8px
            }

            #share-buttons>div.linkedin>svg {
              height: 19px;
              margin-top: 7px
            }

            #share-buttons>div.gplus>svg {
              height: 17px;
              margin-top: 9px;
              position: relative;
              left: 1px
            }

            #share-buttons>div.mail>svg {
              height: 14px;
              margin-top: 11px
            }
          </style>
          <span style=color:silver>Share on: </span>
          <div id=share-buttons>
            <div class=facebook title="Share this on Facebook">
              <svg viewBox="0 0 1792 1792" xmlns=http://www.w3.org/2000/svg>
                <path
                  d="M1343 12v264h-157q-86 0-116 36t-30 108v189h293l-39 296h-254v759h-306v-759h-255v-296h255v-218q0-186 104-288.5t277-102.5q147 0 228 12z">
                </path>
              </svg>
            </div>
            <div class=twitter title="Share this on Twitter">
              <svg viewBox="0 0 1792 1792" xmlns=http://www.w3.org/2000/svg>
                <path
                  d="M1684 408q-67 98-162 167 1 14 1 42 0 130-38 259.5t-115.5 248.5-184.5 210.5-258 146-323 54.5q-271 0-496-145 35 4 78 4 225 0 401-138-105-2-188-64.5t-114-159.5q33 5 61 5 43 0 85-11-112-23-185.5-111.5t-73.5-205.5v-4q68 38 146 41-66-44-105-115t-39-154q0-88 44-163 121 149 294.5 238.5t371.5 99.5q-8-38-8-74 0-134 94.5-228.5t228.5-94.5q140 0 236 102 109-21 205-78-37 115-142 178 93-10 186-50z">
                </path>
              </svg>
            </div>
            <div class=linkedin title="Share this on Linkedin">
              <svg viewBox="0 0 1792 1792" xmlns=http://www.w3.org/2000/svg>
                <path
                  d="M477 625v991h-330v-991h330zm21-306q1 73-50.5 122t-135.5 49h-2q-82 0-132-49t-50-122q0-74 51.5-122.5t134.5-48.5 133 48.5 51 122.5zm1166 729v568h-329v-530q0-105-40.5-164.5t-126.5-59.5q-63 0-105.5 34.5t-63.5 85.5q-11 30-11 81v553h-329q2-399 2-647t-1-296l-1-48h329v144h-2q20-32 41-56t56.5-52 87-43.5 114.5-15.5q171 0 275 113.5t104 332.5z">
                </path>
              </svg>
            </div>
            <div class=gplus title="Share this on Google Plus">
              <svg viewBox="0 0 2304 1792" xmlns=http://www.w3.org/2000/svg>
                <path
                  d="M1437 913q0 208-87 370.5t-248 254-369 91.5q-149 0-285-58t-234-156-156-234-58-285 58-285 156-234 234-156 285-58q286 0 491 192l-199 191q-117-113-292-113-123 0-227.5 62t-165.5 168.5-61 232.5 61 232.5 165.5 168.5 227.5 62q83 0 152.5-23t114.5-57.5 78.5-78.5 49-83 21.5-74h-416v-252h692q12 63 12 122zm867-122v210h-209v209h-210v-209h-209v-210h209v-209h210v209h209z">
                </path>
              </svg>
            </div>
            <div class=mail title="Share this through Email">
              <svg viewBox="0 0 1792 1792" xmlns=http://www.w3.org/2000/svg>
                <path
                  d="M1792 710v794q0 66-47 113t-113 47h-1472q-66 0-113-47t-47-113v-794q44 49 101 87 362 246 497 345 57 42 92.5 65.5t94.5 48 110 24.5h2q51 0 110-24.5t94.5-48 92.5-65.5q170-123 498-345 57-39 100-87zm0-294q0 79-49 151t-122 123q-376 261-468 325-10 7-42.5 30.5t-54 38-52 32.5-57.5 27-50 9h-2q-23 0-50-9t-57.5-27-52-32.5-54-38-42.5-30.5q-91-64-262-182.5t-205-142.5q-62-42-117-115.5t-55-136.5q0-78 41.5-130t118.5-52h1472q65 0 112.5 47t47.5 113z">
                </path>
              </svg>
            </div>
          </div>
        </div>
        <div class="post-content e-content" itemprop=articleBody>
          <h2 id=overview>Overview</h2>
          <p>This is just one of several posts that I will be making regarding a
            study that I am working on, focused on benchmarking and comparing
            different species distribution models (SDMs) using presence-only data. A
            review of the literature that I wrote on this subject can be found
            <a
              href=https://raw.githubusercontent.com/benton-tripp/benton-tripp.github.io/main/_docs/lit_review.pdf>here</a>.
            My GitHub repo for this project can be accessed
            <a href=https://github.com/benton-tripp/presence-only-sdm>here</a>.
          </p>
          <p>This post is focused on gathering and preparing the data that will be
            used throughout my project. More details on the data can be found in the
            links in the next section.</p>
          <h2 id=data-sources>Data Sources</h2>
          <ul>
            <li>State Boundary Data
              <ul>
                <li><a
                    href="https://hub.arcgis.com/datasets/1612d351695b467eba75fdf82c10884f/explore?filters=eyJTVEFURV9BQkJSIjpbIkNPIiwiVlQiLCJOQyIsIk9SIl19&amp;location=48.814319%2C163.610769%2C2.35">ArcGIS
                    Hub</a>
                  (Shapefile download with filters set to the 4 states in question)</li>
              </ul>
            </li>
            <li>eBird Observation Data
              <ul>
                <li><a href=https://ebird.org/data/download>eBird Data Access</a></li>
              </ul>
            </li>
            <li>Raster Data
              <ul>
                <li><a href=https://www.sciencebase.gov/catalog/item/5540e111e4b0a658d79395d9>DEM | Source
                    Page</a>
                  <ul>
                    <li>Download by regions (Great Plains, Northeast, Northwest,
                      Southeast, Southwest, and Upper Midwest)</li>
                  </ul>
                </li>
                <li><a href=https://www.mrlc.gov/data>Urban Imperviousness | Source Page</a>
                  <ul>
                    <li><em>NLCD 2019 Percent Developed Imperviousness (CONUS), NLCD 2019
                        Developed Imperviousness Descriptor (CONUS)</em></li>
                  </ul>
                </li>
                <li><a href=https://www.mrlc.gov/data>Land Cover</a>
                  <ul>
                    <li><em>NLCD 2019 Land Cover (CONUS)</em></li>
                  </ul>
                </li>
                <li><a href=https://www.mrlc.gov/data>Canopy</a>
                  <ul>
                    <li><em>NLCD 2016 USFS Tree Canopy Cover (CONUS)</em></li>
                  </ul>
                </li>
                <li><a href=https://www.nacse.org/prism />Weather (min/max temperature, avg
                  precipitation)</a>
                  <ul>
                    <li>Download weather raster data for “ppt”, “tmax”, “tmin”, 2017-2019
                      at a 4km resolution and 30-year monthly normals at an 800m
                      resolution</li>
                    <li>URL to download 4km data is:
                      <em><a
                          href=https://services.nacse.org/prism/data/public/4km />https://services.nacse.org/prism/data/public/4km/</a></em>
                      <variable>/<year></year>
                      </variable>
                    </li>
                    <li>URL to download 800m data is
                      <em><a
                          href=https://services.nacse.org/prism/data/public/normals/800m />https://services.nacse.org/prism/data/public/normals/800m/</a></em>
                      <variable>/<month></month>
                      </variable>
                    </li>
                  </ul>
                </li>
                <li><a href=https://apps.nationalmap.gov/downloader/# />Hydrography (Water Bodies &amp; Coast) | Source
                  Page</a>
                  <ul>
                    <li><a
                        href=https://prd-tnm.s3.amazonaws.com/StagedProducts/Small-scale/data/Hydrography/hydrusm010g.gdb_nt00897.tar.gz>Download</a>
                    </li>
                  </ul>
                </li>
                <li>Vegetation Index
                  <ul>
                    <li><a href=https://earthexplorer.usgs.gov />USGS Earth Explorer</a> (eVIIRS
                      NDVI, 02/23/21-03/08/21 1km; 05/04/21-05/17/21 1km;
                      09/07/21-09/20/21 1km; 11/30/21-12/13/21 1km)</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
          <h2 id=basic-project-setup>Basic Project Setup</h2>
          <pre><code class=language-r># Load necessary libraries
library(sf)
library(terra)
library(stars)
library(auk)
library(dplyr)
library(readr)
library(data.table)
library(ggplot2)
library(purrr)
library(stringr)
library(fs)

# Hard coded path for downloaded data (in this case, saved in external hard drive)
ext.data.path &lt;- "D:/AvianAnalyticsData"
</code></pre>
          <h2 id=boundary-data>Boundary Data</h2>
          <p>There are four regions explored in this analysis from 2016 through 2019
            (corresponding to the 4 boundary datasets):</p>
          <ul>
            <li>Colorado, 2016-2019</li>
            <li>North Carolina, 2016-2019</li>
            <li>Oregon, 2016-2019</li>
            <li>Vermont, 2016-2019</li>
          </ul>
          <p>For simplicity, only data for the four states that are being used as
            observation area needs to be <a
              href="https://hub.arcgis.com/datasets/1612d351695b467eba75fdf82c10884f/explore?filters=eyJTVEFURV9BQkJSIjpbIkNPIiwiVlQiLCJOQyIsIk9SIl19&amp;location=48.814319%2C163.610769%2C2.35">downloaded
              (as a .shp
              file)</a>.
            By default, the zipped files should be saved in
            <em>US_State_Boundaries.zip</em>. Extract the files into a folder of the same
            name within the data directory, and use the following code to split the
            states into separate files:
          </p>
          <pre><code class=language-r># Define the state abbreviations
states &lt;- c("CO", "NC", "OR", "VT")

# Set the output directory
state.output.dir &lt;- "data/US_State_Boundaries"

output.paths &lt;- file.path(state.output.dir, 
                         paste0(states, "_State_Boundaries.shp"))
if (!all(file.exists(output.paths))) {
  
  # Create the output directory if it doesn't exist
  if (!dir.exists(state.output.dir)) {
    dir.create(state.output.dir)
  }
  
  # Set the path for the shapefile
  shapefile.path &lt;- file.path(ext.data.path,
                              "US_State_Boundaries/US_State_Boundaries.shp")
  
  # Load the shapefile into an sf object
  gdf &lt;- st_read(shapefile.path)
  
  # Transform the coordinate reference system to EPSG:5070
  gdf &lt;- st_transform(gdf, crs = 5070)
  
  
  # Loop through state abbreviations and save individual shapefiles
  for (sa in states) {
    tryCatch({
      state.gdf &lt;- gdf[gdf$STATE_ABBR == sa, ]
      output.path &lt;- file.path(state.output.dir, paste0(sa, "_State_Boundaries.shp"))
      if (!file.exists(output.path)) st_write(state.gdf, output.path, quiet = T)
    }, error = function(e) {
      message(paste0('Failed to save shapefile for state ', sa, ': ', e$message))
    })
  }
}
</code></pre>
          <h2 id=ebird-data>eBird Data</h2>
          <p>There are four regions explored in this analysis from 2016 through 2019
            (corresponding to the 4 boundary datasets):</p>
          <ul>
            <li>Colorado, 2016-2019</li>
            <li>North Carolina, 2016-2019</li>
            <li>Oregon, 2016-2019</li>
            <li>Vermont, 2016-2019</li>
          </ul>
          <p>Species included are:</p>
          <ul>
            <li>Belted Kingfisher</li>
            <li>Cedar Waxwing</li>
            <li>Downy Woodpecker</li>
            <li>Ruddy Duck</li>
            <li>Sanderling</li>
            <li>Sandhill Crane</li>
            <li>Sharp-shinned Hawk</li>
            <li>Wild Turkey</li>
          </ul>
          <h2 id=observation-data-pre-processing>Observation Data Pre-Processing</h2>
          <ol>
            <li>Download each of the regions from the <a href=https://ebird.org/data/download>eBird Download
                Page</a>, filtered by date range (you
              will need to request access annually). They will initially be
              downloaded as compressed folders, so the contents will need to be
              extracted. There is also an eBird API, but the use of the API is
              beyond the scope of this document.</li>
            <li>Using the R <a href=https://cornelllabofornithology.github.io/auk /><code>auk</code>
              package</a>, the
              contents can be filtered and saved.</li>
            <li>Do some basic pre-processing (i.e., select/rename relevant fields,
              filter by date, filter by approval, and filter by invalid
              observations).</li>
            <li>Save results; View data summary.</li>
          </ol>
          <pre><code class=language-r># Specify where your eBird datasets were downloaded to;
ebird.download.dirs &lt;- list.dirs(file.path(ext.data.path, "ebird_downloads"))[-1]

# Specify where the outputs should be saved
ebird.output.dir &lt;- file.path(ext.data.path, "ebird")

if (!dir.exists(ebird.output.dir)) {
  dir.create(ebird.output.dir)
}

# Define species
species &lt;- c("Sandhill Crane", "Sharp-shinned Hawk",
             "Wild Turkey", "Downy Woodpecker",
             "Sanderling", "Cedar Waxwing", 
             "Belted Kingfisher", "Ruddy Duck")

# Parse eBird downloads
for (dir in ebird.download.dirs) {
  # Set the path to EBD text files
  # auk_set_ebd_path(dir, overwrite = T)
  cat("Processing species observation data at", dir, "\n")
  # List .txt files that start with "ebd_"
  in.files &lt;- list.files(path = dir, pattern = "^ebd_.*\\.txt$", full.names = T)

  .sampl &lt;- in.files[grepl("*sampling\\.txt$", in.files)]
  in.file &lt;- in.files[!grepl("*sampling\\.txt$", in.files)]
  
  # Use regular expression to extract state abbreviation
  state.abbreviation &lt;- sub(".*_US-([A-Z]{2})_.*", "\\1", in.file)
  out.file &lt;- file.path(ebird.output.dir, paste0(state.abbreviation, ".txt"))
  
  out.sampling.file &lt;- file.path(ebird.output.dir, 
                                 paste0("sampling_", state.abbreviation, ".txt"))
  if (!file.exists(out.file) &amp; !file.exists(out.sampling.file)) {
    # Read in the filtered data using the `auk` library, saving to `out.file`
    auk_ebd(in.file, .sampl) %&gt;%
      auk_species(species = species) %&gt;% 
      auk_complete() %&gt;% # Add this to keep only complete checklists
      auk_filter(file = out.file, file_sampling = out.sampling.file, 
                 overwrite=T, execute=T)
    
    # Remove "Problem" records
    df &lt;- readr::read_delim(out.file, delim = "\t", 
                            show_col_types = F) %&gt;% 
      suppressWarnings()
    df.samp &lt;- readr::read_delim(out.sampling.file, delim = "\t", 
                                 show_col_types = F) %&gt;%
      suppressWarnings()
    p &lt;- problems(df)
    p.s &lt;- problems(df.samp)
    if (nrow(p) &gt; 0) {
      df &lt;- df %&gt;% slice(-p$row)
      readr::write_delim(df, out.file, delim="\t")
    }
    if (nrow(p.s) &gt; 0) {
      df.samp &lt;- df.samp %&gt;% slice(-p$row)
      readr::write_delim(df.samp, out.sampling.file, delim="\t")
    }
  }
}

# Some basic pre-processing
preprocess.obs &lt;- function(data.path) {
  data &lt;- readr::read_delim(data.path, delim = "\t", show_col_types = F) %&gt;%
    suppressMessages()
  names(data) &lt;- gsub(" ", "\\.", tolower(names(data)))
  data &lt;- data %&gt;%
    filter(observation.date &gt;= as.Date("2016-01-01") &amp; 
             observation.date &lt; as.Date("2020-01-01") &amp;
             approved == 1 &amp; observation.count != "X") %&gt;%
    dplyr::select(common.name, observation.count, latitude, longitude) %&gt;% #observation.date
    group_by(common.name, latitude, longitude) %&gt;% 
    summarize(observation.count = sum(as.numeric(observation.count), na.rm=T),
              .groups="keep") %&gt;%
    ungroup() %&gt;%
    as.data.table()
  return(data)
}

ebird.path &lt;- "data/ebird"
if (!dir.exists(ebird.path)) dir.create(ebird.path)

obs &lt;- purrr::map(states, function(.x) {
  cat("Getting preprocessed observation data in", .x, "\n")
  out.file &lt;- file.path(ebird.path, paste0(.x, ".csv"))
  if (!file.exists(out.file)) {
    out &lt;- preprocess.obs(file.path(ebird.output.dir, paste0(.x, ".txt")))
    fwrite(out, out.file)
  } else {
    out &lt;- fread(out.file)
  }
  out
})

names(obs) &lt;- states
</code></pre>
          <pre><code class=language-r># View summary of data
map_df(states, ~obs[[.x]][, .(.N, state=.x), by=.(common.name)]) %&gt;%
  setorderv(c("common.name", "state")) %&gt;%
  rename(Species="common.name", `Total Obs.`="N", State="state") %&gt;%
  knitr::kable( 
    caption = "Summary of Observation Data", 
    align = c("l", "l", "l"),
  )
</code></pre>
          <table>
            <thead>
              <tr>
                <th style=text-align:left>Species</th>
                <th style=text-align:left>Total Obs.</th>
                <th style=text-align:left>State</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style=text-align:left>Belted Kingfisher</td>
                <td style=text-align:left>4552</td>
                <td style=text-align:left>CO</td>
              </tr>
              <tr>
                <td style=text-align:left>Belted Kingfisher</td>
                <td style=text-align:left>4854</td>
                <td style=text-align:left>NC</td>
              </tr>
              <tr>
                <td style=text-align:left>Belted Kingfisher</td>
                <td style=text-align:left>6367</td>
                <td style=text-align:left>OR</td>
              </tr>
              <tr>
                <td style=text-align:left>Belted Kingfisher</td>
                <td style=text-align:left>2089</td>
                <td style=text-align:left>VT</td>
              </tr>
              <tr>
                <td style=text-align:left>Cedar Waxwing</td>
                <td style=text-align:left>3447</td>
                <td style=text-align:left>CO</td>
              </tr>
              <tr>
                <td style=text-align:left>Cedar Waxwing</td>
                <td style=text-align:left>4443</td>
                <td style=text-align:left>NC</td>
              </tr>
              <tr>
                <td style=text-align:left>Cedar Waxwing</td>
                <td style=text-align:left>8896</td>
                <td style=text-align:left>OR</td>
              </tr>
              <tr>
                <td style=text-align:left>Cedar Waxwing</td>
                <td style=text-align:left>4009</td>
                <td style=text-align:left>VT</td>
              </tr>
              <tr>
                <td style=text-align:left>Downy Woodpecker</td>
                <td style=text-align:left>7513</td>
                <td style=text-align:left>CO</td>
              </tr>
              <tr>
                <td style=text-align:left>Downy Woodpecker</td>
                <td style=text-align:left>11280</td>
                <td style=text-align:left>NC</td>
              </tr>
              <tr>
                <td style=text-align:left>Downy Woodpecker</td>
                <td style=text-align:left>8848</td>
                <td style=text-align:left>OR</td>
              </tr>
              <tr>
                <td style=text-align:left>Downy Woodpecker</td>
                <td style=text-align:left>4699</td>
                <td style=text-align:left>VT</td>
              </tr>
              <tr>
                <td style=text-align:left>Ruddy Duck</td>
                <td style=text-align:left>1728</td>
                <td style=text-align:left>CO</td>
              </tr>
              <tr>
                <td style=text-align:left>Ruddy Duck</td>
                <td style=text-align:left>1345</td>
                <td style=text-align:left>NC</td>
              </tr>
              <tr>
                <td style=text-align:left>Ruddy Duck</td>
                <td style=text-align:left>2097</td>
                <td style=text-align:left>OR</td>
              </tr>
              <tr>
                <td style=text-align:left>Ruddy Duck</td>
                <td style=text-align:left>51</td>
                <td style=text-align:left>VT</td>
              </tr>
              <tr>
                <td style=text-align:left>Sanderling</td>
                <td style=text-align:left>131</td>
                <td style=text-align:left>CO</td>
              </tr>
              <tr>
                <td style=text-align:left>Sanderling</td>
                <td style=text-align:left>1495</td>
                <td style=text-align:left>NC</td>
              </tr>
              <tr>
                <td style=text-align:left>Sanderling</td>
                <td style=text-align:left>665</td>
                <td style=text-align:left>OR</td>
              </tr>
              <tr>
                <td style=text-align:left>Sanderling</td>
                <td style=text-align:left>39</td>
                <td style=text-align:left>VT</td>
              </tr>
              <tr>
                <td style=text-align:left>Sandhill Crane</td>
                <td style=text-align:left>1534</td>
                <td style=text-align:left>CO</td>
              </tr>
              <tr>
                <td style=text-align:left>Sandhill Crane</td>
                <td style=text-align:left>125</td>
                <td style=text-align:left>NC</td>
              </tr>
              <tr>
                <td style=text-align:left>Sandhill Crane</td>
                <td style=text-align:left>2472</td>
                <td style=text-align:left>OR</td>
              </tr>
              <tr>
                <td style=text-align:left>Sandhill Crane</td>
                <td style=text-align:left>77</td>
                <td style=text-align:left>VT</td>
              </tr>
              <tr>
                <td style=text-align:left>Sharp-shinned Hawk</td>
                <td style=text-align:left>2258</td>
                <td style=text-align:left>CO</td>
              </tr>
              <tr>
                <td style=text-align:left>Sharp-shinned Hawk</td>
                <td style=text-align:left>1408</td>
                <td style=text-align:left>NC</td>
              </tr>
              <tr>
                <td style=text-align:left>Sharp-shinned Hawk</td>
                <td style=text-align:left>2807</td>
                <td style=text-align:left>OR</td>
              </tr>
              <tr>
                <td style=text-align:left>Sharp-shinned Hawk</td>
                <td style=text-align:left>758</td>
                <td style=text-align:left>VT</td>
              </tr>
              <tr>
                <td style=text-align:left>Wild Turkey</td>
                <td style=text-align:left>2617</td>
                <td style=text-align:left>CO</td>
              </tr>
              <tr>
                <td style=text-align:left>Wild Turkey</td>
                <td style=text-align:left>2420</td>
                <td style=text-align:left>NC</td>
              </tr>
              <tr>
                <td style=text-align:left>Wild Turkey</td>
                <td style=text-align:left>2460</td>
                <td style=text-align:left>OR</td>
              </tr>
              <tr>
                <td style=text-align:left>Wild Turkey</td>
                <td style=text-align:left>2211</td>
                <td style=text-align:left>VT</td>
              </tr>
            </tbody>
          </table>
          <p>Summary of Observation Data</p>
          <p>Below is a brief snapshot of the data, filtered to
            <code>common.name == "Sandhill Crane"</code> in Oregon:
          </p>
          <pre><code class=language-r># OR Sandhill Crane Map
or.shc &lt;- obs$OR[common.name == "Sandhill Crane"]

ggplot(data = ggplot2::map_data("state") %&gt;% filter(region == "oregon")) +
    geom_polygon(aes(x = long, y = lat, group = group),
                 fill = "#ffffff", color = "black") +
    geom_point(data = or.shc, 
               aes(x = longitude, y = latitude), 
               size=2, alpha=1, fill = "red", shape=21) +
    coord_map() +
    labs(title = "Sandhill Crane observations in OR") + 
    theme_minimal() +
    theme(panel.background = element_blank(),
          axis.text = element_blank(),
          axis.title = element_blank(),
          axis.ticks = element_blank(),
          panel.grid = element_blank())
</code></pre>
          <p><img src=data:, alt></p>
          <h2 id=rasters>Rasters</h2>
          <p>Raster data is a type of digital image represented by a grid of pixels,
            where each pixel has an associated value that represents information
            about a particular geographic area. It is one of the two primary ways to
            represent geospatial data (the other being vector data). In
            environmental studies and geographic analysis, raster data is
            extensively used to represent continuous data such as elevation,
            temperature, or land cover. In this project, raster data serves as the
            basis for various explanatory variables that influence bird species
            distributions, including digital elevation, urban imperviousness, land
            cover, canopy, weather, hydrography, and vegetation index. Each of these
            variables represents environmental conditions that can affect bird
            habitat and distribution.</p>
          <h2 id=raster-pre-processing>Raster Pre-Processing</h2>
          <p>Before using raster data for analysis, it is crucial to preprocess them
            to ensure compatibility, accuracy, and relevancy. Raster pre-processing
            includes a series of steps that prepare and standardize the raster
            datasets for subsequent analyses. Along with some general pre-processing
            steps (and corresponding code), the following sections outline specific
            pre-processing steps tailored for each type of explanatory variable
            being used in the analysis.</p>
          <h3 id=general-raster-pre-processing-steps>General Raster Pre-Processing Steps</h3>
          <ol>
            <li>Load the environmental raster datasets &amp; State Boundary data</li>
            <li>Reproject to CRS EPSG:5070</li>
            <li>Resample each to a common resolution (e.g., 5000 x 5000 meters)</li>
            <li>Mask each raster using State Boundary data</li>
          </ol>
          <p>Following the pre-processing of all rasters, it will also be necessary
            to ensure that the extents of each of the rasters (by state) match, and
            to crop them if necessary to produce uniform extents.</p>
          <pre><code class=language-r># `terra` equivalent of base R `any()` function
terra.any &lt;- function(r) {
  freqs &lt;- freq(r)
  any(freqs[,1] == 1)
}

# Function to fix NA values in a raster (e.g., NULL values are equal to 999, 
# but should be NA)
basic.na.fix &lt;- function(r, na.val) {
  msk &lt;- r == na.val
  cat("Checking for improperly formatted NA values...\n")
  if (terra.any(msk)) {
    r[msk] &lt;- NA
  }
  r
}


# Recursive function to list directories containing .adf files
# Usage:
# raster.directories &lt;- list.raster.dirs.recursive("your_start_directory_path")
list.adf.rasters.recursive &lt;- function(directory.path) {
  
  # List all directories recursively
  all.dirs &lt;- list.dirs(directory.path, recursive = T, full.names = T)
  
  # Filter directories that contain .adf files
  raster.dirs &lt;- all.dirs[sapply(all.dirs, function(dir.path) {
    any(grepl("\\.adf$", list.files(dir.path, full.names = F)))
  })]
  
  return(raster.dirs)
}


general.raster.preprocessing &lt;- function(
    raster.name,
    out.raster.name,
    data.path = "data",
    state.boundary.path = "data/US_State_Boundaries",
    states = c("NC", "CO", "OR", "VT"),
    state.file.suffix = "_State_Boundaries.shp",
    out.path = "../gis630/data",
    crs = 5070,
    wildcard = "*.tif",
    resolution = 5000,
    agg="bilinear",
    recursive.adf.path=F,
    crop.by.state=T,
    na.val=NULL
) {
  # Example usage:
  # general.raster.preprocessing(
  #   raster.name = "canopy/nlcd_2016_treecanopy_2019_08_31",
  #   out.raster.name = "canopy",
  #   out.path = "data/canopy"
  # )
  
  # Make sure output directory exists
  if (!dir.exists(out.path)) dir.create(out.path)
  
  if (!recursive.adf.path) {
    # List all the raster files in the workspace directory
    rasters &lt;- list.files(path = file.path(data.path, raster.name), 
                          pattern = wildcard, 
                          full.names = T)
  } else {
    # List directories containing .adf files
    rasters &lt;- list.adf.rasters.recursive(data.path)
  }
  
  cat("Rasters:", paste(rasters, collapse=", "), "\n")

  # Loop through each raster file in the list
  for (i in 1:length(rasters)) {
    
    raster.path &lt;- rasters[[i]]
    
    if (crop.by.state) {
      
      # Read raster
      cat(paste0("[", i, "/", length(rasters), "]:"), "Reading", raster.path, "\n")
      raster &lt;- rast(raster.path)
      
      # Loop through each state
      for (state in states) {
        
        state.out.file &lt;- file.path(out.path, 
                                    paste0(out.raster.name, "_", 
                                           state, ".tif"))
        if (!file.exists(state.out.file)) {
          # Construct the file path to the state boundary shapefile
          state.path &lt;- file.path(state.boundary.path, 
                                  paste0(state, state.file.suffix))
          
          # Load state shape and reproject it to match raster's CRS
          state.shape &lt;- vect(state.path)
          reprojected.shape &lt;- project(state.shape, crs(raster))
          
          # Crop raster by reprojected state shape
          cat("\tCropping raster for", state, "\n")
          # masked.raster &lt;- terra::mask(raster, reprojected.shape)
          masked.raster &lt;- terra::crop(raster, reprojected.shape, mask=T)
          
          # Reproject
          cat("\tReprojecting raster for", state, "\n")
          reprojected.raster &lt;- project(masked.raster, 
                                        crs(paste0("EPSG:", crs)))
          
          # Clean up
          rm(masked.raster)
          gc()
          
          # Fixing NA values
          if (!is.null(na.val)) {
            reprojected.raster &lt;- basic.na.fix(reprojected.raster, na.val)
          }
          
          template.raster &lt;- ext(reprojected.raster) %&gt;% 
            rast(res=rep(resolution, 2), crs=crs(reprojected.raster))
          
          
          
          # Resample
          current.res &lt;- terra::res(reprojected.raster)
          cat("\tCurrent Resolution:", current.res, "\n")
          cat("\tTarget Factor:", resolution/terra::res(reprojected.raster)[1], "\n")
          if (any(current.res != resolution)) {
            cat("\tResampling raster for", state, "\n")
            # resampled.raster &lt;- terra::aggregate(
            #   reprojected.raster, 
            #   fact=c(resolution/current.res[1], resolution/current.res[2]), 
            #   fun = agg, 
            #   expand = T) %&gt;% suppressWarnings()
            resampled.raster &lt;- terra::resample(reprojected.raster, 
                                                template.raster,
                                                method=agg)
          } else {
            resampled.raster &lt;- reprojected.raster
          }
          
          # Clean up
          rm(reprojected.raster)
          gc()
          
          # Rename final raster
          names(resampled.raster) &lt;- paste0(out.raster.name, "_", state)
          
          # Save raster
          cat("\tSaving to", state.out.file, "\n")
          writeRaster(resampled.raster, state.out.file)
          
          # Clean up
          rm(resampled.raster)
          gc()
        }
      }
    } else {
      path.parts &lt;- stringr::str_split(raster.path, "\\.")[[1]]
      if (length(path.parts) &gt; 1) path.parts &lt;- path.parts[[1]]
      path.parts &lt;- stringr::str_split(path.parts, "/")[[1]]
      r.name &lt;- path.parts[[length(path.parts)]]
      out.file &lt;- file.path(out.path, 
                            paste0(out.raster.name, "_", 
                                   r.name, ".tif"))
      if (!file.exists(out.file)) {
        
        # Read raster
        cat(paste0("[", i, "/", length(rasters), "]:"), "Reading", raster.path, "\n")
        raster &lt;- rast(raster.path)
        
        # Reproject
        cat("\tReprojecting raster...\n")
        reprojected.raster &lt;- project(raster, 
                                      crs(paste0("EPSG:", crs)))
        
        # Clean up
        rm(raster)
        gc()
        
        # Resample
        current.res &lt;- terra::res(reprojected.raster)
        cat("\tCurrent Resolution:", current.res, "\n")
        cat("\tTarget Factor:", resolution/terra::res(reprojected.raster)[1], "\n")
        if (any(current.res != resolution)) {
          cat("\tResampling raster...\n")
          resampled.raster &lt;- terra::aggregate(
            reprojected.raster, 
            fact=c(resolution/current.res[1], resolution/current.res[2]), 
            fun = agg, 
            expand = T) %&gt;% suppressWarnings()
        } else {
          resampled.raster &lt;- reprojected.raster
        }
        
        # Clean up
        rm(reprojected.raster)
        gc()
        
        # Save raster
        cat("\tSaving to", out.file, "\n")
        writeRaster(resampled.raster, out.file)
        
        # Clean up
        rm(resampled.raster)
        gc()
      }
    }
    
    # Clean up
    rm(raster)
    gc()
  }
  cat("Finished general pre-processing.\n")
}
</code></pre>
          <h3 id=digital-elevation-model-dem-pre-processing>Digital Elevation Model (DEM) Pre-Processing</h3>
          <p>The following steps are taken when merging and Pre-processing the DEM
            data downloaded from its
            <a href=https://www.sciencebase.gov/catalog/item/5540e111e4b0a658d79395d9>source</a>:
          </p>
          <ol>
            <li>Merge multiple DEM parts (the raw data download is divided into
              Great Plains, Northeast, Northwest, Southeast, Southwest, and Upper
              Midwest regions).</li>
            <li>Apply general pre-processing of DEM raster (see section on general
              pre-processing).</li>
          </ol>
          <pre><code class=language-r># Combine DEM rasters (Source data has the US split into parts)

# By default, `terra` does most of its work on the disk (as 
# opposed to RAM). However, the temp data for this particular
# process was using ~70GB of storage. This function is set up 
# to reduce this overhead as much as possible.
combine.dem.parts &lt;- function(dem.dir = "data/dem/raw_dem", 
                              output.dir = "data/dem", 
                              output.raster.name = "mosaic_dem") {
  
  if (!dir.exists(output.dir)) dir.create(output.dir)
  
  out.name &lt;- file.path(output.dir, paste0(output.raster.name, ".tif"))
  
  # Get list of rasters recursively
  rasters &lt;- list.adf.rasters.recursive(dem.dir)
  
  # Read the first raster
  cat("1: Reading first raster from", rasters[1], "out of", 
      length(rasters), "rasters. \nWriting to", out.name, ".\n\n")
  
  # Save the combined raster
  writeRaster(rast(rasters[1]), 
              out.name,
              gdal=c("COMPRESS=DEFLATE", "TFW=YES"),
              verbose=T,
              overwrite=T)
  cat("----------------------------\n")
  
  # If there are more rasters, mosaic them iteratively
  if (length(rasters) &gt; 1) {
    for (i in 2:length(rasters)) {
      cat(paste0(i, ":"), "Reading raster from", rasters[i], "out of", 
          length(rasters), "rasters.\nAdding [", i, "/", length(rasters), 
          "] rasters to mosaic.\n\n")
      
      # Save the combined raster
      writeRaster(mosaic(rast(out.name), rast(rasters[i]), fun=mean), 
                  out.name,
                  gdal=c("COMPRESS=DEFLATE", "TFW=YES"),
                  verbose=T,
                  overwrite=T)
      cat("----------------------------\n")
      
      # Clean up
      gc()
    }
  }
  
  cat("Mosaic completed successfully.\n")
}

dem.path &lt;- file.path(ext.data.path, "dem")

if (!file.exists(file.path(dem.path, "mosaic_dem.tif"))) {
  # Combine rasters 
  combine.dem.parts(dem.dir=file.path(dem.path, "raw_dem"),
                    output.dir=dem.path)
}

if (!all(file.exists(paste0("data/dem/dem_", states, ".tif")))) {
  # General pre-processing on each of the DEM parts
  general.raster.preprocessing(
    data.path = ext.data.path,
    raster.name = "dem", 
    out.raster.name = "dem",
    out.path = "data/dem",
    resolution = 5000,
    wildcard="\\.tif$",
    agg="bilinear"
  )
}
</code></pre>
          <h3 id=weather-rasters>Weather Rasters</h3>
          <h4 id=download-weather-raster-data>Download Weather Raster Data</h4>
          <p>In this section, the weather raster data is fetched from its source
            programmatically. The weather data variables considered are
            precipitation (ppt), maximum temperature (tmax), and minimum temperature
            (tmin). The annual weather data at a 4km resolution for the years 2017,
            2018, and 2019. Additionally, monthly 30-year normal data is retrieved
            at an 800m resolution. After downloading, the data is stored in zipped
            format and then extracted.</p>
          <pre><code class=language-r># Downloads and processes weather raster data for specified variables and 
# years at a 4km resolution and 30-year monthly normals at an 800m resolution.
get.weather.data &lt;- function(data.path,
                             out.dir="weather") {
  
  out.path &lt;- file.path(data.path, out.dir)
  if (!dir.exists(out.path)) dir.create(out.path)
  
  vars &lt;- c("ppt", "tmax", "tmin")
  
  # Setup for yearly 4km resolution 
  yrs &lt;- c(2017, 2018, 2019)
  pairs &lt;- expand.grid(vars, yrs)
  
  # Setup for 30 year normal monthly 800m resolution
  mnths &lt;- sprintf("%02d", 1:12)
  norm.pairs &lt;- expand.grid(vars, mnths)
  
  ### Get Raster Data ######
  cat("Getting explanatory Weather Rasters...\n")
  
  # Data documentation:
  # https://www.prism.oregonstate.edu/documents  /PRISM_downloads_web_service.pdf
  
  # 4km yearly data (for 2017-2019)
  for (i in 1:nrow(pairs)) {
    v &lt;- pairs[i, 1]
    y &lt;- pairs[i, 2]
    
    dwnld.out &lt;- file.path(out.path, paste0(v, "_", y, ".zip"))
    dwnld.path &lt;- file.path(out.path, paste0(v, "_", y))
    
    if (!dir.exists(dwnld.path)) {
      dir.create(dwnld.path)
      url &lt;- paste0("https://services.nacse.org/prism/data/public/4km/", v, "/", y)
      cat(paste("Downloading weather data from", url, "...\n"))
      download.file(url, dwnld.out)
      cat(paste("Saved", v, "/", y, "to", dwnld.out, "\n"))
      unzip(dwnld.out, exdir = dwnld.path)
      cat(paste("Extracted", v, "/", y, "from", dwnld.out, "to", dwnld.path, "\n"))
      # file.remove(dwnld.out)
    }
  }
  
  # 800m monthly data (30 year normals)
  for (i in 1:nrow(norm.pairs)) {
    v &lt;- norm.pairs[i, 1]
    m &lt;- norm.pairs[i, 2]
    
    dwnld.out &lt;- file.path(out.path, paste0(v, "_", m, ".zip"))
    dwnld.path &lt;- file.path(out.path, paste0(v, "_", m))
    
    if (!dir.exists(dwnld.path)) {
      url &lt;- paste0("https://services.nacse.org/prism/data/public/normals/800m/", 
                    v, "/", m)
      cat(paste("Downloading weather data from", url, "...\n"))
      download.file(url, dwnld.out)
      cat(paste("Saved", v, "/", m, "to", dwnld.out, "\n"))
      unzip(dwnld.out, exdir = dwnld.path)
      cat(paste("Extracted", v, "/", m, "from", dwnld.out, "to", dwnld.path, "\n"))
      # file.remove(dwnld.out)
    }
  }
  
  cat("Finished getting weather data.\n")
}

get.weather.data(ext.data.path)
</code></pre>
          <h4 id=aggregate-weather-raster-data>Aggregate Weather Raster Data</h4>
          <p>The downloaded weather rasters are aggregated, considering both the
            yearly data and monthly 30-year normals. The aggregation involves
            determining weights for the different resolutions (4km and 800m) and
            then combining them accordingly.</p>
          <pre><code class=language-r>aggregate.weather &lt;- function(data.path,
                              raster.dir="weather",
                              out.dir="weather/aggregated",
                              states=c("CO", "NC", "OR", "VT"),
                              vars=c("ppt", "tmax", "tmin"),
                              yrs=2017:2019) {
  out.path &lt;- file.path(data.path, out.dir)
  raster.path &lt;- file.path(data.path, raster.dir)
  if (!dir.exists(out.path)) dir.create(out.path)
  
  max.temp.data &lt;- "max_temp.tif"
  min.temp.data &lt;- "min_temp.tif"
  avg.prcp.data &lt;- "avg_prcp.tif"
  
  pairs &lt;- expand.grid(vars, yrs)
  mnths &lt;- sprintf("%02d", 1:12)
  norm.pairs &lt;- expand.grid(vars, mnths)
  
  for(v in vars) {
    raster.name &lt;- ifelse(v == "tmax", max.temp.data, 
                          ifelse(v == "tmin", min.temp.data, 
                                 avg.prcp.data))
    v.agg.file &lt;-  file.path(out.path, paste0("aggregated_", raster.name))
    if (!file.exists(v.agg.file)) {
      
      cat(paste0("Checking ", v, "...\n"))
      v.path &lt;- file.path(out.path, v)
      agg.func &lt;- switch(v,
                         tmax = max,
                         tmin = min,
                         ppt = mean,
                         function(x) x) # default to just return the value
      
      # Yearly rasters
      rasters &lt;- list.files(raster.path, full.names=T, 
                            recursive=T, pattern="ppt_stable_4km.*\\.bil$")
      r &lt;- rast(rasters)
      agg.r &lt;- terra::app(r, fun=agg.func)
      
      # Monthly rasters
      norm.rasters &lt;- list.files(raster.path, full.names=T, 
                                 recursive=T, pattern="ppt_30yr.*\\.bil$")
      
      r.norm &lt;- rast(norm.rasters)
      agg.r.norm &lt;- terra::app(r.norm, fun=agg.func)
      
      # Aggregate with weights
      initial.weight.4km &lt;- 3.0
      initial.weight.800m &lt;- 3.0 / 30.0
      total.weight &lt;- initial.weight.4km + initial.weight.800m
      normalized.weight.4km &lt;- initial.weight.4km / total.weight
      normalized.weight.800m &lt;- initial.weight.800m / total.weight
      
      # Resample to match res
      agg.r.resampled &lt;- resample(agg.r, agg.r.norm, method="bilinear")

      combined.raster &lt;- (agg.r.resampled * normalized.weight.4km) + 
        (agg.r.norm * normalized.weight.800m)
      
      # Write result
      writeRaster(combined.raster, 
                  file = v.agg.file, 
                  overwrite = T)
    }
  }
  
  cat("Finished weather data pre-processing.\n")
}

aggregate.weather(ext.data.path)
</code></pre>
          <h4 id=average-precipitation-minmax-temperature-pre-processing>Average Precipitation, Min/Max Temperature
            Pre-Processing</h4>
          <pre><code class=language-r># Average Precipitation

# Apply General Raster Pre-Processing to precipitation
if (!all(file.exists(paste0("data/prcp/avg_prcp_", states, ".tif")))) {
  general.raster.preprocessing(
    data.path=ext.data.path,
    raster.name="weather/aggregated", 
    out.path="data/prcp",
    out.raster.name="avg_prcp",
    resolution=5000,
    wildcard="avg_prcp\\.tif$",
    agg="bilinear"
  )
}

# Minimum Temperature 

# Apply General Raster Pre-Processing to minimum temp
if (!all(file.exists(paste0("data/tmin/tmin_", states, ".tif")))) {
  general.raster.preprocessing(
    data.path=ext.data.path,
    raster.name="weather/aggregated", 
    out.path="data/tmin",
    out.raster.name="tmin",
    resolution=5000,
    wildcard="min_temp\\.tif$",
    agg="bilinear"
  )
}

# Maximum Temperature 

# Apply General Raster Pre-Processing to maximum temp
if (!all(file.exists(paste0("data/tmax/tmax_", states, ".tif")))) {
  general.raster.preprocessing(
    data.path=ext.data.path,
    raster.name="weather/aggregated", 
    out.path="data/tmax",
    out.raster.name="tmax",
    resolution=5000,
    wildcard="max_temp\\.tif$",
    agg="bilinear"
  )
}
</code></pre>
          <h3 id=hydrography-raster-data-conversion>Hydrography Raster Data Conversion</h3>
          <h4 id=extract-from-esri-geodatabase>Extract from ESRI Geodatabase</h4>
          <p>This section handles the extraction of hydrographic data from an ESRI
            Geodatabase. Two of the data sets, Coastline and Waterbody, within the
            geodatabase are converted into individual shapefile formats.</p>
          <pre><code class=language-r>convert.hydro.gdb &lt;- function(data.path = "data/hydrography/",
                              gdb.name = "hydrusm010g.gdb_nt00897/hydrusm010g.gdb",
                              data.sets = c("Coastline", "Waterbody"),
                              output.path = "data/hydrography/") {
  if (!dir.exists(output.path)) dir.create(output.path)
  gdb.path &lt;- file.path(data.path, gdb.name)
  # Iterate over each dataset and convert
  for (ds in data.sets) {
    out.file &lt;- file.path(output.path, paste0(ds, ".shp"))
    if (!file.exists(out.file)) {
      # Read the geodatabase layer using st_read
      data &lt;- st_read(dsn = file.path(data.path, gdb.name), layer = ds, quiet = T)
      # Write the shapefile
      st_write(obj = data, dsn = out.file, quiet = T)
      cat(sprintf("Converted %s from geodatabase to shapefile.\n", ds))
    }
  } 
}

convert.hydro.gdb(data.path=file.path(ext.data.path, "hydrography"),
                  output.path=file.path(ext.data.path, "hydrography")) %&gt;%
  suppressWarnings()
</code></pre>
          <h4 id=convert-waterbody-shapefile-to-raster--pre-process>Convert Waterbody Shapefile to Raster &amp;
            Pre-Process</h4>
          <p>The waterbody data previously extracted as a shapefile is then
            transformed into raster format. The steps entail:</p>
          <ol>
            <li>Cleaning the data by filtering out specific undesirable features.</li>
            <li>Reprojecting the data into a standard coordinate reference system
              (CRS).</li>
            <li>Rasterizing the shapefile data with a default resolution.</li>
            <li>Using dilation to expand the waterbody boundaries in the raster.
              Dilation is a process to enlarge or expand a feature. In this
              context, the waterbody raster is dilated in multiple stages to
              represent different proximities to the water.</li>
            <li>Applying the general raster pre-processing steps.</li>
          </ol>
          <pre><code class=language-r>update.wb.array &lt;- function(r) {
  r.updated &lt;- copy(r)
  
  w &lt;- matrix(1,3,3)
  # Perform the dilation operation multiple times
  dilated1 &lt;- terra::focal(r, w = w, fun = max)
  dilated2 &lt;- terra::focal(dilated1, w =w, fun = max)
  dilated3 &lt;- terra::focal(dilated2, w = w, fun = max)
  dilated4 &lt;- terra::focal(dilated3, w = w, fun = max)
  
  r.updated[dilated4 == 1] &lt;- 0.2
  r.updated[dilated3 == 1] &lt;- 0.4
  r.updated[dilated2 == 1] &lt;- 0.6
  r.updated[dilated1 == 1] &lt;- 0.8
  r.updated[r == 1] &lt;- 1
  
  return(r.updated)
}

# Convert waterbody shapefile to raster
process.waterbody.shp &lt;- function(out.path,
                                  data.path="data/hydrography",
                                  states=c("CO", "VT", "NC", "OR")) {
  out.file &lt;- file.path(out.path, 'Waterbody.tif')
  if (!file.exists(out.file)) {
    if (!dir.exists(out.path)) dir.create(out.path)
    
    cat("Cleaning waterbody data...\n")
    gdf &lt;- st_read(file.path(data.path, 'Waterbody.shp'))
    
    # Filter out records where Feature == "Lake Dry"
    gdf &lt;- gdf %&gt;% filter(Feature != "Lake Dry")
    
    gdf$waterbody &lt;- 1
    
    cat("Reprojecting...\n")
    gdf &lt;- st_transform(gdf, crs = 5070)
    
    cat("Converting to raster using template...\n")
    
    # Initialize raster resolution at 1km prior to dilation
    # (will be updated to desired resolution)
    template.raster &lt;- ext(gdf) %&gt;% 
      rast(res=rep(1e3, 2), crs=crs(gdf))
    
    r &lt;- terra::rasterize(gdf, template.raster, 
                               field="waterbody", values=1, background=0)
    
    # Add dilation
    r.updated &lt;- update.wb.array(r)
    
    # Save raster
    terra::writeRaster(r.updated, out.file, overwrite=T)
  }
}

process.waterbody.shp(out.path=file.path(ext.data.path, "waterbody"),
                      data.path=file.path(ext.data.path, "hydrography"))

# Apply General Raster Pre-Processing to Waterbodies
if (!all(file.exists(paste0("data/waterbody/waterbody_", states, ".tif")))) {
  general.raster.preprocessing(
    data.path=ext.data.path,
    raster.name="waterbody", 
    out.path="data/waterbody",
    out.raster.name="waterbody",
    resolution=5000,
    wildcard="\\.tif$",
    agg="bilinear"
  )
}
</code></pre>
          <h4 id=convert-coastline-shapefile-to-raster--pre-process>Convert Coastline Shapefile to Raster &amp;
            Pre-Process</h4>
          <p>The coastline data, like the waterbody data, undergoes a conversion from
            shapefile to raster format. The steps are:</p>
          <ol>
            <li>Basic data cleaning and reprojection to a standard CRS.</li>
            <li>A buffer is applied to the coastline vectors. This adds a specified
              distance around the coastline, effectively creating a zone around
              the coast.</li>
            <li>Rasterization of the buffered coastline data.</li>
            <li>Dilation of the coastline raster to indicate proximity zones.</li>
            <li>General raster pre-processing.</li>
          </ol>
          <pre><code class=language-r># Convert coastline shapefile to raster
process.coastline.shp &lt;- function(out.path,
                                  data.path="data/hydrography",
                                  states=c("CO", "VT", "NC", "OR")) {
  out.file &lt;- file.path(out.path, 'Coastline.tif')
  if (!file.exists(out.file)) {
    if (!dir.exists(out.path)) dir.create(out.path)
    
    cat("Cleaning coastline data...\n")
    
    # Read data
    gdf &lt;- st_read(file.path(data.path, 'Coastline.shp'))
    
    # Reproject
    cat("Reprojecting...\n")
    gdf &lt;- st_transform(gdf, crs = 5070)
    
    # Buffer
    cat("Buffering coastline vectors...\n")
    gdf &lt;- st_buffer(gdf, dist = 500)
    
    gdf$coastline &lt;- 1
    
    cat("Converting to raster using template...\n")
    
    # Initialize raster resolution at 1km prior to dilation
    # (will be updated to desired resolution)
    template.raster &lt;- ext(gdf) %&gt;% 
      rast(res=rep(1e3, 2), crs=crs(gdf))
    
    r &lt;- terra::rasterize(gdf, template.raster, 
                          field="coastline", values=1, background=0)
    
    # Add dilation
    r.updated &lt;- update.wb.array(r)
    
    # Save raster
    terra::writeRaster(r.updated, out.file, overwrite=T)
  }
}


process.coastline.shp(out.path=file.path(ext.data.path, "coastline"),
                      data.path=file.path(ext.data.path, "hydrography"))

# Apply General Raster Pre-Processing to coastline
if (!all(file.exists(paste0("data/coastline/coastline_", states, ".tif")))) {
  general.raster.preprocessing(
    data.path=ext.data.path,
    raster.name="coastline", 
    out.path="data/coastline",
    out.raster.name="coastline",
    resolution=5000,
    wildcard="\\.tif$",
    agg="bilinear"
  )
}
</code></pre>
          <h3 id=general-pre-processing-of-remaining-rasters>General Pre-Processing of Remaining Rasters</h3>
          <p>The remaining rasters, upon downloading them from their respective
            sources, require no additional pre-processing other than the “general”
            pre-processing steps described previously:</p>
          <ul>
            <li>Urban Imperviousness</li>
            <li>Land Cover</li>
            <li>NDVI</li>
            <li>Tree Canopy</li>
          </ul>
          <p>For land cover, note the 20 different Land Cover hierarchical categories
            (i.e., each of them falls under a “parent” category, see <a
              href=https://www.mrlc.gov/data/legends/national-land-cover-database-class-legend-and-description>National
              Land
              Cover Database Class Legend and
              Description</a>):</p>
          <ul>
            <li>Water:
              <ul>
                <li>11: Open Water</li>
                <li>12: Perennial Ice/Snow</li>
              </ul>
            </li>
            <li>Developed
              <ul>
                <li>21: Developed, Open Space</li>
                <li>22: Developed, Low Intensity</li>
                <li>23: Developed, Medium Intensity</li>
                <li>24: Developed, High Intensity</li>
              </ul>
            </li>
            <li>Barren
              <ul>
                <li>31: Barren Land (Rock/Sand/Clay)</li>
              </ul>
            </li>
            <li>Forest
              <ul>
                <li>41: Deciduous Forest</li>
                <li>42: Evergreen Forest</li>
                <li>43: Mixed Forest</li>
              </ul>
            </li>
            <li>Shrubland
              <ul>
                <li>51: Dwarf Shrub</li>
                <li>52: Shurb/Scrub</li>
              </ul>
            </li>
            <li>Herbaceous
              <ul>
                <li>71: Grassland/Herbaceous</li>
                <li>72: Sedge/Herbaceous</li>
                <li>73: Lichens</li>
                <li>74: Moss</li>
              </ul>
            </li>
            <li>Planted/Cultivated
              <ul>
                <li>81: Pasture/Hay</li>
                <li>82: Cultivated Crops</li>
              </ul>
            </li>
            <li>Wetlands
              <ul>
                <li>90: Woody Wetlands</li>
                <li>95: Emergent Herbaceous Wetlands</li>
              </ul>
            </li>
          </ul>
          <pre><code class=language-r># Urban Imperviousness Pre-Processing

if (!all(file.exists(paste0("data/urban_imperviousness/urban_imperviousness_", 
                            states, ".tif")))) {
  # Use the combined raster for the general raster pre-processing
  general.raster.preprocessing(
    data.path = ext.data.path,
    raster.name="urban_imperviousness", 
    out.raster.name="urban_imperviousness",
    out.path="data/urban_imperviousness",
    resolution=5000,
    wildcard="\\.tif$",
    agg="bilinear"
  )
}


# Land Cover Pre-Processing

if (!all(file.exists(paste0("data/land_cover/land_cover_", states, ".tif")))) {
  # Apply "general raster preprocessing" 
  general.raster.preprocessing(
    data.path = ext.data.path,
    raster.name="land_cover/nlcd_2019_land_cover_l48_20210604", 
    out.raster.name="land_cover",
    out.path="data/land_cover",
    resolution=5000,
    wildcard="\\.tif$",
    agg="near"
  )
}


# NDVI Pre-Processing

# Iterate through each season
for (season in c("Spring", "Summer", "Fall", "Winter")) {
  if (!all(file.exists(file.path("data/NDVI", paste0(season, "_NDVI_", 
                                                     states, ".tif"))))) {
    cat(paste0("Applying raster preprocessing for ", season, "...\n"))
    tryCatch({
      # Using the combined raster, apply "general raster preprocessing" 
      # (resample, reproject, mask)
      
      general.raster.preprocessing(
        data.path=ext.data.path,
        raster.name=paste0("NDVI/US_eVSH_NDVI-", season, "-2021"), 
        out.raster.name=paste0(season, "_NDVI"),
        out.path="data/NDVI",
        wildcard="*1KM\\.VI_NDVI.*\\.tif$",
        resolution=5000,
        agg="bilinear")
      cat("-----------------\n")
    }, error = function(e) {
      cat(paste0("An error occurred while processing ", season, ": ", e$message, "\n"))
    })
  }
}

# Canopy Pre-Processing

# Apply "general raster preprocessing" 

if (!all(file.exists(paste0("data/canopy/canopy_", states, ".tif")))) {
  general.raster.preprocessing(
    data.path=ext.data.path,
    raster.name="canopy/nlcd_tcc_CONUS_2016_v2021-4", 
    out.raster.name="canopy",
    out.path="data/canopy",
    resolution=5000,
    wildcard="\\.tif$",
    agg="bilinear"
  )
}
</code></pre>
          <h2 id=final-raster-pre-processing-steps>Final Raster Pre-Processing Steps</h2>
          <h3 id=ensuring-shapesize-conformity>Ensuring Shape/Size Conformity</h3>
          <p>In order to use the rasters to be saved as layers in a single raster,
            they must exactly conform in resolution, CRS, and shape/extent. Due to
            slight variations in the datasets, the raster extents are not perfect
            (although they are nearly so). Now that all of the rasters are
            available, a common “intersect” region can be determined for each state,
            and all of the rasters for each state can be cropped to fit that region.</p>
          <p>Once this is completed, the rasters can be joined into combined,
            multi-layer rasters and saved.</p>
          <pre><code class=language-r># Function to intersect two extents
intersect.extents &lt;- function(ext1, ext2) {
  xmin &lt;- max(ext1[1], ext2[1])
  xmax &lt;- min(ext1[2], ext2[2])
  ymin &lt;- max(ext1[3], ext2[3])
  ymax &lt;- min(ext1[4], ext2[4])
  
  if (xmin &gt; xmax | ymin &gt; ymax) {
    stop("The extents do not overlap!")
  }
  
  ext(c(xmin, xmax, ymin, ymax))
}

# Get all rasters

all.rasters &lt;- map(states, function(s) {
  files &lt;- list.files("data", pattern=paste0("_", s, "\\.tif$"), 
                      recursive=T, full.names=T)
  
  rasters &lt;- map(files, ~rast(.x))
  
  # Get extent intersect, and update raster extents
  extents &lt;- map(rasters, ~ext(.x) %&gt;% as.vector())
  ext.intersect &lt;- reduce(extents, intersect.extents)
  rasters &lt;- map(rasters, ~crop(.x, ext.intersect))
  
  # Align all rasters to common grid
  rasters &lt;- map(rasters[2:length(rasters)], ~project(.x, rasters[[1]]))
  
  # Check extents, resolutions, and CRS of each raster
  extents &lt;- map(rasters, ~ext(.x) %&gt;% as.vector())
  resolutions &lt;- map(rasters, ~res(.x))
  .crs &lt;- map(rasters, ~crs(.x))
  
  # Set names
  .names &lt;- map_chr(rasters, ~names(.x))
  names(files) &lt;- .names
  names(rasters) &lt;- .names
  names(extents) &lt;- .names
  names(resolutions) &lt;- .names
  names(.crs) &lt;- .names
  # Return list
  list(
    files=files,
    rasters=rasters %&gt;% reduce(c), # Make raster stack
    ext=extents,
    ext.intersect=ext.intersect,
    res=resolutions,
    crs=.crs,
    names=.names
  )
})

names(all.rasters) &lt;- states
if (!all(file.exists(paste0("data/final_rasters/", states, ".tif")))) {
  if (!dir.exists("data/final_rasters")) dir.create("data/final_rasters")
  walk(states, ~writeRaster(all.rasters[[.x]]$rasters, 
                            paste0("data/final_rasters/", .x, ".tif"),
                            overwrite=T))
} 
</code></pre>
          <h2 id=combine-raster-and-observation-data>Combine Raster and Observation Data</h2>
          <p>When both the observation data and raster data pre-processing has been
            completed, points can be extracted from each of the rasters
            corresponding to the observation points. These tabular datasets are what
            will be used to train/test presence-only models.</p>
          <pre><code class=language-r># Combine rasters and observations
for (state in states) {
  
  input.file &lt;- file.path("data", "ebird", paste0(state, ".csv"))
  output.file &lt;- file.path("data", "ebird", paste0(state, ".shp"))
  
  if (!file.exists(output.file)) {
    cat(sprintf("Reading %s data...\n", state))
    
    df &lt;- fread(input.file)
    
    # Convert the bird data to a sf object
    cat(sprintf("Converting %s data to sf...\n", state))
    geo.df &lt;- st_as_sf(df, coords = c("longitude", "latitude"), crs = 4326)
    
    
    # Get centroid of the entire sightings
    cat(sprintf("Getting centroid of %s data...\n", state))
    centroid &lt;- st_centroid(st_union(geo.df))
    
    # Assign each point a distance attribute, being the distance from the centroid
    cat(sprintf("Calculating distances from centroid for %s...\n", state))
    geo.df$distance &lt;- st_distance(geo.df, centroid)
    
    # Sort the sf object by the distance attribute
    cat(sprintf("Sorting by distance from centroid in %s data...\n", state))
    geo.df &lt;- geo.df %&gt;% arrange(distance)
    
    # Drop the distance attribute 
    cat(sprintf("Saving %s data to %s...\n", state, output.file))
    geo.df$distance &lt;- NULL
    
    st_write(geo.df, output.file) %&gt;% suppressWarnings()
    cat("--------------\n")
  }
  
  if (!dir.exists(file.path("data", "final"))) dir.create(file.path("data", "final"))
  out.file.all &lt;- file.path("data", "final", paste0("all_data_", state, ".rds"))
  if (!file.exists(out.file.all)) {
    r &lt;- all.rasters[[state]]$rasters
    r.names &lt;- all.rasters[[state]]$names
    
    cat(sprintf("Extracting points to values for %s...\n", state))
    # Load observations shapefile
    geo.df &lt;- st_read(output.file) 
    
    
    # Define target CRS and update
    target.crs &lt;- "EPSG:5070"
    cat(sprintf("Updating CRS for %s...\n", state))
    geo.df &lt;- st_transform(geo.df, target.crs)
    
    # Extract raster values
    for (r.name in r.names) {
      cat("\tExtracting", r.name, "values for", state, "\n")
      x &lt;- terra::extract(r[[r.name]], geo.df)[[r.name]]
      geo.df[[gsub(paste0("_", state), "", r.name)]] &lt;- x
    }
    
    # Update crs back
    geo.df &lt;- st_transform(geo.df, 4326)
    
    # Fix names; Filter NA values
    r.names &lt;- gsub(paste0("_", state), "", r.names)
    names(geo.df) &lt;- c("common.name", "observations", "geometry", r.names)
    geo.df$state &lt;- state
    coords &lt;- st_coordinates(geo.df) %&gt;% as.data.frame() %&gt;% setnames(c("lon", "lat"))
    geo.df &lt;- geo.df %&gt;%
      cbind(coords) %&gt;%
      filter(dplyr::if_all(r.names, ~!is.na(.))) %&gt;%
      select(common.name, state, lon, lat, everything()) %&gt;%
      mutate(urban_imperviousness = urban_imperviousness %&gt;% 
               as.character() %&gt;% 
               as.numeric(),
             
      ) %&gt;%
      suppressWarnings() 
    
    saveRDS(geo.df, out.file.all)
    cat("--------------\n")
  }
} 
</code></pre>
          <hr>
          <div class=post_navi><a class="post_navi-item nav_prev"
              href=https://benton-tripp.github.io/posts/tree-volume-using-random-forests.html
              title="Tree Volume using Random Forests">
              <div class=post_navi-arrow>&lt;</div>
              <div class=post_navi-label>Previous Post</div>
              <div><span>Tree Volume using Random Forests</span></div>
            </a><a class="post_navi-item nav_next"
              href=https://benton-tripp.github.io/posts/2023-09-17-sdm-benchmark-study-part-2-exploratory-analysis.html
              title="SDM Benchmark Study Part 2: Exploratory Analysis">
              <div class=post_navi-arrow>&gt;</div>
              <div class=post_navi-label>Next Post</div>
              <div><span>SDM Benchmark Study Part 2: Exploratory Analysis</span></div>
            </a></div>
        </div>
        <a class="u-url sf-hidden"
          href=https://benton-tripp.github.io/posts/sdm-benchmark-study-part-1-data-preparation.html hidden></a>
      </article>
    </div>
  </main>
  <footer class="site-footer h-card">
    <data class=u-url href= /></data>
    <div class=wrapper>
      <h2 class=footer-heading>Benton's Portfolio/Blog</h2>
      <div class=footer-col-wrapper>
        <div class="footer-col footer-col-1">
          <ul class=contact-list>
            <li class=p-name>Benton Tripp
            <li><a class=u-email href=mailto:bentontripp@gmail.com>bentontripp@gmail.com</a>
          </ul>
        </div>
        <div class="footer-col footer-col-2">
          <ul class=social-media-list>
            <li><a href=https://github.com/benton-tripp><svg class=svg-icon>
                  <symbol id=github fill-rule=evenodd clip-rule=evenodd stroke-linejoin=round stroke-miterlimit=1.414>
                    <path
                      d="M8 0C3.58 0 0 3.582 0 8c0 3.535 2.292 6.533 5.47 7.59.4.075.547-.172.547-.385 0-.19-.007-.693-.01-1.36-2.226.483-2.695-1.073-2.695-1.073-.364-.924-.89-1.17-.89-1.17-.725-.496.056-.486.056-.486.803.056 1.225.824 1.225.824.714 1.223 1.873.87 2.33.665.072-.517.278-.87.507-1.07-1.777-.2-3.644-.888-3.644-3.953 0-.873.31-1.587.823-2.147-.09-.202-.36-1.015.07-2.117 0 0 .67-.215 2.2.82.64-.178 1.32-.266 2-.27.68.004 1.36.092 2 .27 1.52-1.035 2.19-.82 2.19-.82.43 1.102.16 1.915.08 2.117.51.56.82 1.274.82 2.147 0 3.073-1.87 3.75-3.65 3.947.28.24.54.73.54 1.48 0 1.07-.01 1.93-.01 2.19 0 .21.14.46.55.38C13.71 14.53 16 11.53 16 8c0-4.418-3.582-8-8-8">
                    </path>
                  </symbol>
                  <use xlink:href=#github></use>
                </svg> <span class=username>benton-tripp</span></a>
            <li><a href=https://www.linkedin.com/in/bentontripp><svg class=svg-icon>
                  <symbol id=linkedin fill-rule=evenodd clip-rule=evenodd stroke-linejoin=round stroke-miterlimit=1.414>
                    <path
                      d="M13.632 13.635h-2.37V9.922c0-.886-.018-2.025-1.234-2.025-1.235 0-1.424.964-1.424 1.96v3.778h-2.37V6H8.51v1.04h.03c.318-.6 1.092-1.233 2.247-1.233 2.4 0 2.845 1.58 2.845 3.637v4.188zM3.558 4.955c-.762 0-1.376-.617-1.376-1.377 0-.758.614-1.375 1.376-1.375.76 0 1.376.617 1.376 1.375 0 .76-.617 1.377-1.376 1.377zm1.188 8.68H2.37V6h2.376v7.635zM14.816 0H1.18C.528 0 0 .516 0 1.153v13.694C0 15.484.528 16 1.18 16h13.635c.652 0 1.185-.516 1.185-1.153V1.153C16 .516 15.467 0 14.815 0z"
                      fill-rule=nonzero></path>
                  </symbol>
                  <use xlink:href=#linkedin></use>
                </svg> <span class=username>bentontripp</span></a>
            <li><a href=https://benton-tripp.github.io/feed.xml><svg class=svg-icon>
                  <symbol id=rss fill-rule=evenodd clip-rule=evenodd stroke-linejoin=round stroke-miterlimit=1.414>
                    <path
                      d="M12.8 16C12.8 8.978 7.022 3.2 0 3.2V0c8.777 0 16 7.223 16 16h-3.2zM2.194 11.61c1.21 0 2.195.985 2.195 2.196 0 1.21-.99 2.194-2.2 2.194C.98 16 0 15.017 0 13.806c0-1.21.983-2.195 2.194-2.195zM10.606 16h-3.11c0-4.113-3.383-7.497-7.496-7.497v-3.11c5.818 0 10.606 4.79 10.606 10.607z">
                    </path>
                  </symbol>
                  <use xlink:href=#rss></use>
                </svg> <span>rss</span></a>
          </ul>
        </div>
        <div class="footer-col footer-col-3">
          <p>This blog is a place for me to document and present different projects I have been working on.</p>
        </div>
      </div>
    </div>
  </footer>